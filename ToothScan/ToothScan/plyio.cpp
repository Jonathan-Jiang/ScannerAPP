#include "plyio.h"
#include "tinyply.h"

namespace tinyply
{

	plyio::plyio()
	{
	}

	plyio::~plyio()
	{
	}


	void plyio::write_ply_example(const std::string & filename, orth::MeshModel &mm,const bool is_binary)
	{
		// geometry cube = make_cube_geometry();

		std::filebuf fb;

		if (is_binary)
		{
			fb.open(filename, std::ios::out | std::ios::binary);

		}
		else
		{
			fb.open(filename, std::ios::out);

		}

		std::ostream outstream(&fb);
		if (outstream.fail()) throw std::runtime_error("failed to open " + filename);
	


		const size_t numVerticesBytes = mm.C.size();
		std::vector<uint4> verts_doubles;
		if (numVerticesBytes>0)
		{
			verts_doubles.resize(mm.C.size());
			for (size_t point_index = 0; point_index < mm.C.size(); point_index++)
			{
				verts_doubles[point_index].x = mm.C[point_index].x;
				verts_doubles[point_index].y = mm.C[point_index].y;
				verts_doubles[point_index].z = mm.C[point_index].z;
				verts_doubles[point_index].w = 255;
			}

		}




		PlyFile cube_file;

		cube_file.add_properties_to_element("vertex", { "x", "y", "z" },
			Type::FLOAT64, mm.P.size(), reinterpret_cast<uint8_t*>(mm.P[0].data()), Type::INVALID, 0);

		if (mm.N.size()>0)
		{
			cube_file.add_properties_to_element("vertex", { "nx", "ny", "nz" },
				Type::FLOAT64, mm.N.size(), reinterpret_cast<uint8_t*>(mm.N[0].data()), Type::INVALID, 0);
		}

		if (numVerticesBytes>0)
		{
			cube_file.add_properties_to_element("vertex", { "red", "green", "blue","alpha" },
				Type::UINT8, verts_doubles.size(), reinterpret_cast<uint8_t*>(verts_doubles.data()), Type::INVALID, 0);
		}


		if (mm.F.size()>0)
		{
			cube_file.add_properties_to_element("face", { "vertex_indices" },
				Type::UINT32, mm.F.size(), reinterpret_cast<uint8_t*>(mm.F[0].data()), Type::UINT8, 3);
		}


		cube_file.get_comments().push_back("generated by lyzk");

		// Write an ASCII file

		if (is_binary)
		{
			cube_file.write(outstream, true);
		}
		else
		{
			cube_file.write(outstream, false);

		}

		//// Write a binary file
		
	}

	void plyio::read_ply_file(const std::string & filepath, orth::MeshModel &mm)
	{
		try
		{
			std::ifstream ss(filepath, std::ios::binary);
			if (ss.fail()) throw std::runtime_error("failed to open " + filepath);

			PlyFile file;
			file.parse_header(ss);

			std::cout << "........................................................................\n";
			for (auto c : file.get_comments()) std::cout << "Comment: " << c << std::endl;
			for (auto e : file.get_elements())
			{
				std::cout << "element - " << e.name << " (" << e.size << ")" << std::endl;
				for (auto p : e.properties) std::cout << "\tproperty - " << p.name << " (" << tinyply::PropertyTable[p.propertyType].str << ")" << std::endl;
			}
			std::cout << "........................................................................\n";

			// Tinyply treats parsed data as untyped byte buffers. See below for examples.
			std::shared_ptr<PlyData> vertices, normals, faces, colors;

			// The header information can be used to programmatically extract properties on elements
			// known to exist in the header prior to reading the data. For brevity of this sample, properties 
			// like vertex position are hard-coded: 
			try { vertices = file.request_properties_from_element("vertex", { "x", "y", "z" }); }
			catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

			try { normals = file.request_properties_from_element("vertex", { "nx", "ny", "nz" }); }
			catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

			////try { texcoords = file.request_properties_from_element("vertex", { "u", "v" }); }
			////catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

			//try { colors = file.request_properties_from_element("vertex", { "red", "green", "blue"}); }
			//catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

			// Providing a list size hint (the last argument) is a 2x performance improvement. If you have 
			// arbitrary ply files, it is best to leave this 0. 
			try { faces = file.request_properties_from_element("face", { "vertex_indices" }, 6); }
			catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

			std::cout << "read start" << std::endl;
			file.read(ss);
			std::cout << "read end 3" << std::endl;

			if (vertices) std::cout << "\tRead " << vertices->count << " total vertices " << std::endl;
			if (normals) std::cout << "\tRead " << normals->count << " total vertex normals " << std::endl;
			//if (colors) std::cout << "\tRead " << colors->count << " total vertex texcoords " << std::endl;
			if (faces) std::cout << "\tRead " << faces->count << " total faces (triangles) " << std::endl;
			std::cout << "read end 2" << std::endl;
			mm.P.resize(vertices->count);
			//
			mm.N.resize(normals->count);
			//mm.C.resize(colors->count);
			// type casting to your own native types - Option B
			{
				const size_t numVerticesBytes = vertices->buffer.size_bytes();
				std::cout << vertices->buffer.size_bytes() << std::endl;
				if (vertices->t == tinyply::Type::FLOAT32) {
					std::vector<float3> verts_doubles(vertices->count);
					std::memcpy(verts_doubles.data(), vertices->buffer.get(), numVerticesBytes);
					for (size_t point_index = 0; point_index < vertices->count; point_index++)
					{
						mm.P[point_index].x = verts_doubles[point_index].x;
						mm.P[point_index].y = verts_doubles[point_index].y;
						mm.P[point_index].z = verts_doubles[point_index].z;
					}
				}
				if (vertices->t == tinyply::Type::FLOAT64) {
					std::memcpy(mm.P[0].data(), vertices->buffer.get(), numVerticesBytes);
				}

			}
			std::cout << "vertices end" << std::endl;
			{
				const size_t numNormalsBytes = normals->buffer.size_bytes();
				std::cout << normals->buffer.size_bytes() << std::endl;
				if (normals->t == tinyply::Type::FLOAT32) {
					std::vector<float3> verts_doubles(normals->count);
					std::memcpy(verts_doubles.data(), normals->buffer.get(), numNormalsBytes);
					for (size_t point_index = 0; point_index < normals->count; point_index++)
					{
						mm.N[point_index].x = verts_doubles[point_index].x;
						mm.N[point_index].y = verts_doubles[point_index].y;
						mm.N[point_index].z = verts_doubles[point_index].z;
					}
				}
				if (vertices->t == tinyply::Type::FLOAT64) {
					std::memcpy(mm.N[0].data(), normals->buffer.get(), numNormalsBytes);
				}

			}
			std::cout << "normal end" << std::endl;
			//{
			//	const size_t numVerticesBytes = colors->buffer.size_bytes();
			//	if (colors->t == tinyply::Type::UINT8) {
			//		std::vector<uintc3> verts_doubles(colors->count);
			//		std::memcpy(verts_doubles.data(), colors->buffer.get(), numVerticesBytes);
			//		for (size_t point_index = 0; point_index < colors->count; point_index++)
			//		{
			//			mm.C[point_index].x = verts_doubles[point_index].x;
			//			mm.C[point_index].y = verts_doubles[point_index].y;
			//			mm.C[point_index].z = verts_doubles[point_index].z;
			//		}
			//	}
			//	//if (colors->t == tinyply::Type::UINT8) {
			//	//	std::memcpy(mm.C[0].data(), colors->buffer.get(), numVerticesBytes);
			//	//}
			//}
			//std::cout << "color end" << std::endl;

			//std::cout <<" face count : " << faces->count << std::endl;
			//if (faces->t == tinyply::Type::INT16)
			//{
			//	std::cout << "INT16" << std::endl;
			//}
			//if (faces->t == tinyply::Type::UINT16)
			//{
			//	std::cout << "UINT16" << std::endl;
			//}
			//if (faces->t == tinyply::Type::INT32)
			//{
			//	std::cout << "INT32" << std::endl;
			//}
			//if (faces->t == tinyply::Type::UINT32)
			//{
			//	std::cout << "UINT32" << std::endl;
			//}
			mm.F.resize(faces->count);
			{
				const size_t numVerticesBytes = faces->buffer.size_bytes();
				std::cout << faces->buffer.size_bytes() << std::endl;

				/*if (faces->t == tinyply::Type::UINT16)*/ {
					std::vector<uintf3> triangles(faces->count);
					std::memcpy(triangles.data(), faces->buffer.get(), numVerticesBytes/2);

					for (size_t point_index = 0; point_index < faces->count; point_index++)
					{
						mm.F[point_index].x = triangles[point_index].x;
						mm.F[point_index].y = triangles[point_index].y;
						mm.F[point_index].z = triangles[point_index].z;
					}
				}
				//if (faces->t == tinyply::Type::UINT32) {
				//	std::memcpy(mm.F[0].data(), faces->buffer.get(), numVerticesBytes);
				//}

			}
		}
		catch (const std::exception & e)
		{
			std::cerr << "Caught tinyply exception: " << e.what() << std::endl;
		}
	}
}

